package src.LeetCode.Algorithms.Medium;
/*��̖	2�M�Ɣ�		1�Ă���	���
 * -----------------------------------
 *0		0			0		��0���Y��
 *1		1			1		��0���Y��+1
 * -----------------------------------
 *2		10			1 		��0���Y��+1
 *3		11			2 		��1���Y��+1
 * -----------------------------------
 *4		100			1		��0���Y��+1
 *5 	101			2 		��1���Y��+1
 *6 	110			2		��2���Y��+1
 *7	 	111			3		��3���Y��+1
 * -----------------------------------
 *8 	1000		1		��0���Y��+1	
 *9 	1001		2		��1���Y��+1
 *10 	1010		2		��2���Y��+1
 *11 	1011		3		��3���Y��+1
 *12	1100		2		��4���Y��+1
 *13	1101		3		��5���Y��+1
 *14 	1110		3		��6���Y��+1
 *15 	1111		4		��7���Y��+1
*/
public class CountingBits {
	public int[] countBits(int num) {
		int[] result = new int[num + 1];
		
		int powOf2 = 1; //檢測數(是否可被2整除的數)一開始為2的0次方
		int before = 1; //此變量是用來存取前面結果(1的個數)
		for(int i = 1; i <= num; i ++) {
			if(i == powOf2) { //若此數為2的次方
				result[i] = 1; //當此數可被2整除時，只有一個1
				powOf2 <<= 1; //將檢測數右移一位(乘2的效果)
				
				before = 1; //重置，表示1的個數會依據前面的結果而定
			} else { //否則
				result[i] = result[before] + 1; //1的個數是根據前面1的個數 + 1
				before = before + 1; //將此變量往前挪
			}
		}
	    return result;
	}
}
