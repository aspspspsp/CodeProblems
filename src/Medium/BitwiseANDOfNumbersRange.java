package Medium;

public class BitwiseANDOfNumbersRange {
    /*
    题目大意:
　　给一个范围，返回这个范围中所有的数按位相与最后的结果。 
    解题思路:
    当m!=n，那么最末位必定等0，因为[m, n]必定包含奇偶数，相与最末位等0。
    可以将m，n都右移一位，记为mk、 nk，这样就相当于将[m, n]之间的所有的
    数都右移动了一位，当mk=nk的时候，说明之前[m, n]之间的数右移一位后是
    相等的，右移后的数作AND操作，结果还是m(=n)，所以操作就可以停止了记录
    右移的次数，offset，m>>offset即为所求结果 
    
    例子1:
    5的二进制为101,7的二进制位111，其公共头部为100。
    例子2:
    若计算3到5的按位或，3的二进制位11，5的二进制位101，没有公共头部，返回0。
    
    为什么这个代码能够工作呢？让我们先看看4位二进制的从0到a的按位异或。
    0000 <- 0  [a]
    0001 <- 1  [1]
    0010 <- 3  [a+1]
    0011 <- 0  [0]
    0100 <- 4  [a]
    0101 <- 1  [1]
    0110 <- 7  [a+1]
    0111 <- 0  [0]
    1000 <- 8  [a]
    1001 <- 1  [1]
    1010 <- 11 [a+1]
    1011 <- 0  [0]
    1100 <- 12 [a]
    1101 <- 1  [1]
    1110 <- 15 [a+1]
    1111 <- 0  [0]
上述代码中，我们看到，f函数其实就是返回[0, a]的按位异或。
对于主体函数，f(b)表示从[0, b]的异或，f(a-1)表示[0, a-1]
的异或，f(b)^f(a-1)则等于[a, b]的异或。因为任何数异或自身都为0。
    */
    public int rangeBitwiseAnd(int m, int n) {
        int offset = 0;
        
        while(m != n) {
            m >>= 1;
            n >>= 1;
            offset ++;
        }
        
        return m << offset;
    }
}